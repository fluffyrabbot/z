#!/usr/bin/perl
exec($^X, '-d', "$0", grep {!/^--debug$/} @ARGV) if grep {/^--debug$/} @ARGV;

use v5.34;
use warnings;
use utf8;

use FindBin;
use lib "$FindBin::RealBin/lib";

use ZChat;
use ZChat::Storage;
use ZChat::Config;
use ZChat::Pin;
use ZChat::Utils ':all';

use bansi;
use Getopt::Long::Descriptive;
# use Getopt::Long::Descriptive::Opts;
use POSIX qw(strftime);
use LWP::UserAgent;
use JSON::XS;
use URI::Escape;
use Data::Dumper;
use List::Util qw(max);
use Clipboard;
use MIME::Base64;
use Image::Magick;
use File::Slurper qw(write_text read_text read_lines read_binary);
use File::Basename;
use Encode qw(encode_utf8 decode);
use String::ShellQuote;
use File::Copy;
use File::Temp qw(tempfile);
use File::Compare;
use Carp 'confess';
use Term::ReadLine;
use Term::ReadLine::Gnu qw(RL_PROMPT_START_IGNORE RL_PROMPT_END_IGNORE);
no warnings 'once';

# Terminal control
my $C_IGN_S = RL_PROMPT_START_IGNORE;
my $C_IGN_E = RL_PROMPT_END_IGNORE;

# Global settings
select STDERR; $|=1;
select STDOUT; $|=1;
binmode *STDIN, "raw";
binmode *STDOUT, "utf8";
binmode *STDERR, "utf8";

my $user = `whoami`; chomp $user;
my $def_npredict = 8192;
my $def_pin_max = 50;
my @cmd_tts = ("voice-piper-interactive");
my $verbose = 0;
my $verbose_resp = 0;
my $editor = $ENV{EDITOR} // 'vim';

# Colors
my $clr_user = a24bg(35,0,35). a24fg(230,255,255);
my $clr_sys = a24bg(5,20,40). a24fg(230,245,255);
my $intmode_prompt = "$C_IGN_S$gra${C_IGN_E}>> $C_IGN_S$rst$clr_user$C_IGN_E";
my $clr_notice_bg = a24bg(30,155,30);
my $clr_notice_fg = $whi;

my ($opt, $usage) = describe_options(
    'z %o [prompt]',
    [ 'help|h',             "This beautiful help" ],
    [ 'verbose|v+',         "Increase verbosity", { default => 0 } ],
    [ 'verbose-resp|vr+',   "Verbose response data" ],
    [ 'image|img:s@',       "Provide images (use [img] or [img-1]..[img-N] in prompt) (This is old and needs updating)" ],
    [ 'clipboard|cb',       "Use clipboard content as Query" ],
    [ 'interactive|int|i',  "Interactive mode (query on CLI can be included as first message)" ],
    [ 'echo1|e',            "Echo back initial prompt" ],
    [ 'echo-delineated|echod|ee', "Echo with <echo></echo> and <reply></reply> tags" ],
    [ 'raw|r',              "Raw output (no processing)" ],
    [ 'tokens-full',        "Output tokens of input text" ],
    [ 'token-count|T',      "Count tokens in input text" ],
    [ 'ctx',                "Get running model n_ctx" ],
    [ 'metadata',           "Get running model metadata" ],
    [ 'n_predict|P=i',      "Limit prediction length to N tokens", { default => $def_npredict } ],
    [ 'play-user|pu',       "Play user text with TTS" ],
    [ 'play-resp|pr',       "Play response text with TTS" ],
    [ 'probs:s',            "Return probabilities for top N tokens" ],
    [ 'no-color|nc',        "Disable color in interactive mode" ],
    [ 'grammar|g=s',        "Force a grammar" ],
    [ 'store-user|su|S',    "Store session in user global config" ],
    [ 'store-session|ss',   "Store in current session config" ],
    [ 'thought|think',      "Do not remove reasoning sections" ],
    [ 'thought-re|tre',       "Specify a regex for stripping reasoning" ],
    [],
    [ 'Session management:' ],
    [ 'session|n=s',        "Session name (slash-separated path)" ],
    [],
    [ 'System Prompt:' ],
    [ 'system-str|sstr=s', "Set system prompt as a literal string (highest explicit source after file)" ],
    [ 'system-file|sfile=s', "Set system prompt from a file (relative paths allowed)" ],
    [ 'system-persona|spersona|persona=s', "Set system prompt by persona name (resolved by persona tool)" ],
    [ 'system|sys=s',      "Auto-resolve through -file then -persona (but does NOT accept a string)" ],
    [],
    [ 'History:' ],
    [ 'wipe|w',             "Wipe conversation history" ],
    [ 'no-history|H',       "Do not use history (no load, no store)" ],
    [ 'input-only|I',       "Use history BUT do not write to it" ],
    [ 'edit-hist|eh|E',     "Edit history in $editor" ],
    [ 'owrite-last=s',      "Overwrite last history message for role (u|user|a|assistant) with current prompt" ],
    [ 'output-last|conv1|c1=s', "Write last message content: '-' => stdout, '-PATH' or 'PATH' => write to file" ],
    [],
    [ 'Utility:' ],
    [ 'list-sys|sys-list|L', "List available file and 'persona'-based system prompts." ],
    [ 'fallbacks-ok',       "OK to use fallbacks if things fail" ],
    [],
    [ 'Message pinning:' ],
    [ 'help-pins',          "Show detailed help for pinning" ],
    [ 'pin=s@',             "Add pinned message(s)" ],
    [ 'pin-file=s@',        "Add pinned message(s) from file(s)" ],
    [ 'pin-list',           "List all pinned messages" ],
    [ 'pin-sum',            "List pinned messages (one-line summary)" ],
    [ 'pin-sum-len=i',      "Max length for pin summary lines" ],
    [ 'pin-write=s',        "Overwrite pin by index: --pin-write '0=new content'" ],
    [ 'pin-clear',          "Clear all pinned messages" ],
    [ 'pin-rm=i@',          "Remove pin(s) by index" ],
    [ 'pins-sys-max=i',     "Max system pins", { default => $def_pin_max } ],
    [ 'pins-user-max=i',    "Max user pins", { default => $def_pin_max } ],
    [ 'pins-ast-max=i',     "Max assistant pins", { default => $def_pin_max } ],

    [ 'pin-sys=s@',         "Add system pin(s)" ],
    [ 'pin-user=s@',        "Add user pin(s)" ],
    [ 'pin-ast=s@',         "Add assistant pin(s) (shorthand: ast)" ],
    [ 'pin-ua-pipe=s@',     "Add paired user|||assistant pin(s)" ],
    [ 'pin-ua-json=s@',     "Add paired pins from JSON object(s) with {user,assistant}" ],
    [ 'pins-clear-user',    "Clear user pins only" ],
    [ 'pins-clear-ast',     "Clear assistant pins only" ],
    [ 'pins-clear-sys',     "Clear system pins only" ],
    [ 'pin-shim=s',         "Set shim appended to user/assistant pinned messages" ],
    [ 'pin-sys-mode=s',     "How to include system pins in system prompt: vars|concat|both (default: vars) (eg. <: \$pins_str :> or use array in pins" ],
    [ 'help-sys-pin-vars',  "Show a quick example of template vars to use for system pins", ],
);

@ARGV = map { decode('UTF-8', $_) } @ARGV;

if ($opt->help) { print($usage->text), exit; }

$verbose = $opt->verbose;
set_verbose($verbose); # In Utils
$verbose_resp = $opt->verbose_resp;

if ($opt->help_pins) {
    my $help_path = File::Spec->catfile($FindBin::RealBin, 'help', 'pins.md');
    if (-e $help_path) { print read_text($help_path) }
    else { say "No pins help found (expected $help_path)" }
    exit;
}

if ($opt->help_sys_pin_vars) {
    print <<~'EOT';

        === For accessing as an array ($pins) ===
        <: $pins.size ? '## Pinned Rules\n' : '' :>
        : if $pins.size {
        :   for $pins -> $x {
        * <: $x :>
        :   }
        : }

        === Using the concatenated string version ($pins_str) ===
        ## Pinned Rules
        <: $pins_str :>
        EOT
    exit;
}

# Parse input
my $uprompt;
if (@ARGV) {
    if ($ARGV[0] eq '-') {
        undef $/;
        $uprompt = <STDIN>;
        $uprompt = decode('UTF-8', $uprompt, Encode::FB_QUIET);
    } else {
        $uprompt = join(' ', @ARGV);
    }
}

# Echo handling
if (defined $uprompt) {
    if ($opt->echo_delineated) {
        print "<echo>", $uprompt, ($uprompt !~ /\n$/ ? "\n" : ''), "</echo>\n";
    } elsif ($opt->echo1) {
        print $uprompt, ($uprompt !~ /\n$/ ? "\n" : '');
    }
}

# # Validate system prompt options
# # I think this is handled in the module now.
# my @conflict_pairs = qw(system system-file system-string system-persona);
# for my $i (0 .. $#conflict_pairs+1) {
#     for my $j ($i+1 .. $#conflict_pairs+1) {
#         my $a = $conflict_pairs[$i];
#         my $b = $conflict_pairs[$i];
#         if ($opt->_specified($a) && $opt->_specified($b)) {
#             $a =~ s/_/-/g; # Done with them, just reuse
#             $b =~ s/_/-/g;
#             die "${bred}ERROR: Cannot use both --$a and --$b simultaneously$rst\n";
#         }
#     }
# }

# Handle images and clipboard
my @image_data;
my $use_images = 0;

if ($opt->clipboard) {
    my $clip_data = Clipboard->paste;
    
    if ($clip_data =~ /^\xFF\xD8/) {  # JPEG binary
        my $image_id = 'img';
        my $base64_image = encode_base64($clip_data);
        push @image_data, { id => $image_id, data => $base64_image };
        $use_images = 1;
    } elsif ($clip_data =~ /^\p{IsPrint}/) {  # Text
        if (defined $uprompt) {
            die "${bred}ERROR: --clipboard and query are not compatible$rst\n";
        }
        $uprompt = encode_utf8($clip_data);
    } else {
        die "${bred}ERROR: Unsupported clipboard content$rst\n";
    }
}

if ($opt->image) {
    for my $index (0..$#{$opt->image}) {
        my $image_path = $opt->image->[$index];
        unless (-e $image_path) {
            die "${bred}ERROR: Image file not found: $image_path$rst\n";
        }

        my $image = Image::Magick->new;
        $image->Read($image_path);
        my $base64_image = encode_base64($image->ImageToBlob());

        my $image_id = (@{$opt->image} == 1) ? 'img' : "img-" . ($index + 1);
        my $ora = a24fg(255,128,30);
        sel 1, "${ora}Attaching image ${whi}$image_id$ora, Base64 len: " . length($base64_image);
        
        push @image_data, { id => $image_id, data => $base64_image };
    }
    $use_images = 1;
}

# Initialize ZChat
my $zchat = ZChat->new(
    session => $opt->session // '',
    system       => $opt->system,
    system_file  => $opt->system_file,
    system_str   => $opt->system_str,
    system_persona => $opt->system_persona,
    verbose => $verbose,
    pin_shims => (defined $opt->pin_shim ? { user=>$opt->pin_shim, assistant=>$opt->pin_shim } : undef),
    pin_sys_mode => ($opt->pin_sys_mode // undef),
);

# Handle utility commands first
if ($opt->list_sys) {
    # Files under $ZCHAT_DATADIR/sys (if present) and personas from `persona --list`
    my @files;
    my $sys_dir;
    if (exists $ENV{ZCHAT_DATADIR}) {
        my $maybe = File::Spec->catdir($ENV{ZCHAT_DATADIR}, 'sys');
        $sys_dir = $maybe if -d $maybe;
    }
    if ($sys_dir) {
        opendir(my $dh, $sys_dir);
        @files = sort grep { $_ !~ /^\./ && -f File::Spec->catfile($sys_dir, $_) } readdir($dh);
        closedir $dh;
    }
    say "System files" . ($sys_dir ? " ($sys_dir)" : "") . ":";
    say(@files ? map { "  $_" } @files : "  (none found)");
    my @personas;
    my $plist = `persona --list 2>/dev/null`;
    if ($? == 0 && defined $plist) {
        @personas = grep { length } map { chomp; $_ } split(/\n/, $plist);
    }
    say "Personas:";
    say(@personas ? map { "  $_" } @personas : "  (none found or persona tool unavailable)");
    exit;
}

if ($opt->token_count) {
    my $input_text = $uprompt // '';
    if ($input_text eq '') {
        say 1;  # Empty input = 1 token
    } else {
        my $token_count = $zchat->{core}->count_tokens($input_text);
        say $token_count;
    }
    exit;
}

if ($opt->tokens_full) {
    my $input_text = $uprompt // '';
    die "${bred}No input text provided$rst\n" if $input_text eq '';
    
    my @tokens = $zchat->{core}->tokenize($input_text, with_pieces => 1);
    my $json = JSON::XS->new->utf8->canonical(1)->encode(\@tokens);
    say $json;
    exit;
}

if ($opt->ctx) {
    my $n_ctx = $zchat->{core}->get_n_ctx();
    say $n_ctx;
    exit;
}

if ($opt->metadata) {
    my $model_info = $zchat->{core}->get_model_info();
    for my $key (sort keys %$model_info) {
        say "$key -> $model_info->{$key}";
    }
    exit;
}

# Pin management commands
if ($opt->pin_list) {
    my $pins = $zchat->list_pins();
    if (@$pins) {
        for my $i (0..$#$pins) {
            my $pin = $pins->[$i];
            say "$i: [$pin->{role}/$pin->{method}] $pin->{content}";
        }
    } else {
        say "No pins found.";
    }
    exit;
}

if ($opt->pin_sum) {
    my $max_len = $opt->pin_sum_len // 80;
    my $summaries = $zchat->{pin_mgr}->get_pins_summary($max_len);
    if (@$summaries) {
        say $_ for @$summaries;
    } else {
        say "No pins found.";
    }
    exit;
}

if ($opt->pin_clear) {
    $zchat->clear_pins();
    sel 1, "All pins cleared.";
    exit;
}

if ($opt->pin_rm) {
    my @indices = @{$opt->pin_rm};
    # Sort in reverse order to avoid index shifting
    @indices = sort { $b <=> $a } @indices;
    
    my $removed = 0;
    for my $index (@indices) {
        if ($zchat->remove_pin($index)) {
            $removed++;
        } else {
            warn "Failed to remove pin at index $index";
        }
    }
    sel 1, "Removed $removed pin(s).";
    exit;
}

if ($opt->pins_clear_sys || $opt->pins_clear_user || $opt->pins_clear_ast) {
    my $did = 0;
    $did += $zchat->{pin_mgr}->clear_pins_by_role('system')    if $opt->pins_clear_sys;
    $did += $zchat->{pin_mgr}->clear_pins_by_role('user')      if $opt->pins_clear_user;
    $did += $zchat->{pin_mgr}->clear_pins_by_role('assistant') if $opt->pins_clear_ast;
    sel 1, "Cleared role-specific pins." if $did;
    exit;
}

if ($opt->pin_write) {
    # Format: --pin-write 0='new content'
    if ($opt->pin_write =~ /^(\d+)=(.*)$/) {
        my ($index, $new_content) = ($1, $2);
        
        # Remove old pin and add new one at same position
        my $pins = $zchat->list_pins();
        if ($index < @$pins) {
            $zchat->remove_pin($index);
            # For simplicity, just add new pin (order might change)
            $zchat->pin($new_content, 
                role => $pins->[$index]{role},
                method => $pins->[$index]{method}
            );
            sel 1, "Pin $index updated.";
        } else {
            die "Pin index $index does not exist\n";
        }
    } else {
        die "Invalid --pin-write format. Use: --pin-write '0=new content'\n";
    }
    exit;
}

# Add pins from CLI options
if ($opt->pin) {
    for my $pin_content (@{$opt->pin}) {
        $zchat->pin($pin_content);
    }
}

if ($opt->pin_file) {
    for my $pin_file (@{$opt->pin_file}) {
        unless (-e $pin_file && -r $pin_file) {
            die "${bred}ERROR: Pin file not found or readable: $pin_file$rst\n";
        }
        my $items = load_pipes_file($pin_file);   # ARRAY of hashes/UA pairs
        for my $it (@$items) {
            if (ref($it) eq 'HASH' && exists $it->{role} && exists $it->{content}) {
                $zchat->pin($it->{content}, role => $it->{role}, method => ($it->{method}//'msg'));
            } else {
                # Treat as UA pair (pipes reader yields {user,assistant})
                $zchat->pin($it->{user}, role=>'user', method=>'msg')           if defined $it->{user} && $it->{user} ne '';
                $zchat->pin($it->{assistant}, role=>'assistant', method=>'msg') if defined $it->{assistant} && $it->{assistant} ne '';
            }
        }
    }
}

# Direct role-specific pins
for my $s (@{ $opt->pin_sys  // [] }) { $zchat->pin($s, role=>'system',    method=>'concat'); }
for my $s (@{ $opt->pin_user // [] }) { $zchat->pin($s, role=>'user',      method=>'msg');    }
for my $s (@{ $opt->pin_ast  // [] }) { $zchat->pin($s, role=>'assistant', method=>'msg');    }

# UA pipe: "user|||assistant"
for my $pair (@{ $opt->pin_ua_pipe // [] }) {
    my ($u,$a) = split(/\|\|\|/, $pair, 2);
    $u = '' unless defined $u; $a = '' unless defined $a;
    $zchat->pin($u, role=>'user', method=>'msg')           if length $u;
    $zchat->pin($a, role=>'assistant', method=>'msg')      if length $a;
}

# UA JSON: {"user":"...","assistant":"..."}
for my $json (@{ $opt->pin_ua_json // [] }) {
    my $obj = eval { JSON::XS->new->decode($json) } // {};
    if (ref($obj) eq 'HASH') {
        $zchat->pin($obj->{user}, role=>'user', method=>'msg')             if defined $obj->{user} && $obj->{user} ne '';
        $zchat->pin($obj->{assistant}, role=>'assistant', method=>'msg')   if defined $obj->{assistant} && $obj->{assistant} ne '';
    } else {
        warn "Ignoring invalid --pin-ua-json payload";
    }
}

# History management
if ($opt->wipe) {
    if ($opt->input_only) {
        # This may be unexpected behavior so notify
        sel 0, "Input-only mode - wiping only in memory.";
    } elsif ($opt->no_history) {
        # This may be unexpected behavior so notify
        sel 0, "No-history mode - wiping only in memory.";
    } else {
        # Clear history through storage
        $zchat->{storage}->save_history($zchat->get_session_name(), []);
        sel 1, "${yel}Conversation history wiped.$rst";
    }
    # exit unless defined $uprompt; # Other options might still be functioning even if wipe was done (like storing settings), so don't exit.
}

# Storage operations (These come BEFORE being blocked by edit history)
if ($opt->store_user) {
    my %store_opts;
    $store_opts{session} = $opt->session if $opt->session;

    $store_opts{system_prompt}  = $opt->system_str  if defined $opt->system_str;
    $store_opts{system_file}    = $opt->system_file if defined $opt->system_file;
    $store_opts{system_persona} = $opt->system_persona if defined $opt->system_persona;

    $store_opts{pin_shims}   = { user=>$opt->pin_shim, assistant=>$opt->pin_shim } if defined $opt->pin_shim;
    $store_opts{pin_sys_mode}= $opt->pin_sys_mode if defined $opt->pin_sys_mode;

    $zchat->store_user_config(%store_opts);
    sel(1, "Stored user config: ", join(", ", map { "$_ => $store_opts{$_}" } sort keys %store_opts)) if %store_opts;
    exit unless defined $uprompt;
}

if ($opt->store_session) {
    my %store_opts;

    $store_opts{system_prompt}  = $opt->system_str  if defined $opt->system_str;
    $store_opts{system_file}    = $opt->system_file if defined $opt->system_file;
    $store_opts{system_persona} = $opt->system_persona if defined $opt->system_persona;

    $store_opts{pin_shims}   = { user=>$opt->pin_shim, assistant=>$opt->pin_shim } if defined $opt->pin_shim;
    $store_opts{pin_sys_mode}= $opt->pin_sys_mode if defined $opt->pin_sys_mode;

    $zchat->store_session_config(%store_opts);
    say "Stored session config: " . join(", ", sort keys %store_opts) if %store_opts;
    exit unless defined $uprompt;
}

# Overwrite last message for a specific role (does not affect pins)
if (my $role_to_overwrite = $opt->owrite_last) {
    die "Input-only was selected (-I). Overwriting it makes no sense.\n" if $opt->input_only;
    die "No-history was selected (-H). Overwriting it makes no sense.\n" if $opt->no_history;
    die "--owrite-last requires a prompt (from stdin or arguments) to use as the new content.\n"
        unless defined $uprompt && $uprompt ne '';

    $role_to_overwrite = 'user'      if $role_to_overwrite eq 'u';
    $role_to_overwrite = 'assistant' if $role_to_overwrite eq 'a';
    die "--owrite-last must be one of: (u|user|a|assistant).\n"
        unless $role_to_overwrite =~ /^(user|assistant)$/;

    my $session_name = $zchat->get_session_name();
    my $messages = $zchat->{storage}->load_history($session_name);
    die "Cannot --owrite-last: conversation history is empty.\n" unless @$messages;
    die "Cannot --owrite-last: No '$role_to_overwrite' message found to overwrite.\n" unless grep { $_->{role} && $_->{role} eq $role_to_overwrite } @$messages;

    for (my $i = $#$messages; $i >= 0; $i--) {
        if ($messages->[$i]{role} && $messages->[$i]{role} eq $role_to_overwrite) {
            $messages->[$i]{content} = $uprompt;
            last;
        }
    }
    $zchat->{storage}->save_history($session_name, $messages);
    sel 1, "Successfully overwrote last '$role_to_overwrite' message in history.";
    exit;
}

if ($opt->edit_hist) {
    die "Input-only mode - editing makes no sense\n" if $opt->input_only;
    die "No-history mode - editing makes no sense\n" if $opt->no_history;
    
    my $session_name = $zchat->get_session_name();
    my $session_dir = $zchat->{storage}->get_session_dir($session_name);
    my $history_file = File::Spec->catfile($session_dir, 'history.json');
    
    system($editor, '--', $history_file);
    exit;
}

# Output last message content (to stdout or a file)
if (defined $opt->output_last) {
    die "ERROR: Request for --output-last while also providing a query. We don't know how to resolve the mixed output. Aborting."
        if defined $uprompt;
    my $session_name = $zchat->get_session_name();
    my $messages = $zchat->{storage}->load_history($session_name);
    die "Conversation history is empty; nothing to output.\n" unless @$messages;

    my $last = $messages->[-1]{content} // '';
    my $dest = $opt->output_last;

    if ($dest eq '-') {
        print $last;
    } else {
        my $path = ($dest =~ /^-(.+)$/) ? $1 : $dest;
        write_file($path, $last, { umask=>0177, makepath=>1 })
            or die "Error writing last message to '$path'\n";
        sel 1, "Wrote last message to $path";
    }
    exit;
}

# Validate we have input for completion
my $intmode = $opt->interactive;
if (!$intmode && !defined $uprompt) {
    die "${bred}No query provided. See -h or use -i for interactive mode.$rst\n";
}

# Disable colors in non-interactive mode
if (!$intmode || $opt->no_color) {
    $clr_user = '';
    $clr_sys = '';
}

# Show session info
sel 1, "${clr_notice_bg}${clr_notice_fg}Session: " . $zchat->get_session_name() . "$rst";

# Terminal setup for interactive mode
my $term;
if ($intmode) {
    $term = Term::ReadLine->new("z") or die "Cannot create Term::ReadLine object";
    
    my $readline_histfile = "/tmp/zchat_readline-$user.json";
    $term->ReadHistory($readline_histfile) if -e $readline_histfile;
    
    # Set up terminal reset on enter
    $term->add_defun("accept-line", sub {
        my ($count, $key) = @_;
        print "$rst";
        $term->call_function("accept-line", $count, $key);
    }, ord("\n"));
}

# Main completion loop
while (1) {
    # Process current query if we have one
    if (defined $uprompt && $uprompt ne '') {
        # TTS for user input
        tts_str($uprompt) if $opt->play_user;
        
        print $clr_sys if $intmode;
        
        # Prepare completion options
        my %complete_opts = (
            stream => !$opt->raw,
            raw => $opt->raw,
            show_thought => $opt->thought,
            n_predict => $opt->n_predict,
            grammar => $opt->grammar,
        );
        
        # Add probability tracking if requested
        $complete_opts{n_probs} = $opt->probs if defined $opt->probs;
        

        if ($opt->thought && ($opt->thought_re//0)) {
            die "Cannot specify both --thought and --thought-re.\n";
        }
        if (!$opt->thought) {
            if ($opt->thought_re//0) {
                $complete_opts{remove_pattern} = $opt->thought_re;
            } else {
                $complete_opts{remove_pattern} = qr/(?:<think>)?.*?<\/think>\s*/s;
            }
        }
        
        # Add images to user input if present
        if (@image_data) {
            # For now, just mention images in prompt
            my @img_mentions;
            for my $img (@image_data) {
                push @img_mentions, "[$img->{id}]";
            }
            $uprompt .= "\n\nImages attached: " . join(", ", @img_mentions);
        }
        
        # Make completion request
        my $response = $zchat->complete($uprompt, %complete_opts);
        
        say $rst if $intmode;
        
        # TTS for response
        tts_str($response) if $opt->play_resp;
        
        # Save to history (unless disabled)
        unless ($opt->no_history || $opt->input_only) {
            $zchat->{storage}->append_to_history($zchat->get_session_name(), $uprompt, $response);
        }
    }
    
    # Interactive mode: get next input
    if ($intmode) {
        my $line = $term->readline($intmode_prompt);
        print "$rst";
        
        # Quit conditions
        last if !defined($line) || $line =~ /^(q|quit)$/i;
        
        $term->addhistory($line) if $line ne '';
        my $readline_histfile = "/tmp/zchat_readline-$user.json";
        $term->write_history($readline_histfile);
        
        $uprompt = $line;
    }
    
    last unless $intmode;
}

# Save readline history
if ($intmode) {
    my $readline_histfile = "/tmp/zchat_readline-$user.json";
    $term->write_history($readline_histfile);
}

exit;

# Utility functions
sub tts_str {
    my $str = shift;
    open(my $ttsf, "|-", @cmd_tts) || die "Couldn't execute TTS: $cmd_tts[0]: $!";
    print $ttsf $str;
    close $ttsf;
}

__END__

=head1 NAME

z - Command-line interface to ZChat LLM system

=head1 SYNOPSIS

    # Basic usage
    z "Hello, how are you?"
    
    # Choose/override a system prompt
    z --system-file prompts/coding.md "Write a Perl function"
    z --system-str  "You are terse"    "Refactor this module"
    z --system-persona reviewer         "Do a design review"

    # Interactive mode
    z -i
    
    # Pin management
    z --pin "You are a helpful assistant" --pin-list
    z --pin-sum
    z --pin-clear
    
    # Session management  
    z -n myproject/analysis "What should I focus on?"
    z --system-file prompts/base.md -S              # Store in user global config
    z -n project --system-str "Prefer REST" --ss   # Store in current session
    
    # Images
    z --img photo.jpg "What's in this image?"
    z --clipboard  # Use clipboard content
    
    # Utility
    z -T "Count tokens in this text"
    z --ctx  # Show model context size
    z --list-sys | -L  # List file and 'persona'-based system prompts

=head1 DESCRIPTION

Command-line interface to the ZChat modular LLM system. Supports
conversation history, pinned messages, sessions, and more.  System prompts
are sourced from files, literal strings, or personas with clear precedence.

=cut
# vim: et
